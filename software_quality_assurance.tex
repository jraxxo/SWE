%% nicht vergessen draft raus zu nehmen, um echte Bilder einzubinden und die Problem-Vierecke verschwinden zu lassen
\documentclass[11pt,a4paper,oneside,svgnames]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{eurosym}
\usepackage[british]{babel}
\usepackage{float}

\usepackage{longtable}
\usepackage{ae}
\usepackage{hyperref}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{kpfonts}
\usepackage[explicit]{titlesec}
\usepackage[acronym,nonumberlist,style=tree]{glossaries}
\usepackage{amssymb}
\usepackage[left=3.65cm,right=3.65cm]{geometry}
\usepackage{listings}


%BEGIN Chapter Definition

\makeatletter
\def\thickhrulefill{\leavevmode \leaders \hrule height 1ex \hfill \kern \z@}
\def\@makechapterhead#1{%
  \vspace*{10\p@}%
  {\parindent \z@ \raggedleft \reset@font
            \scshape \@chapapp{} \thechapter
        \par\nobreak
        \interlinepenalty\@M
    \Huge \bfseries #1\par\nobreak
    %\vspace*{1\p@}%
    \hrulefill
    \par\nobreak
    \vskip 50\p@
  }}
\def\@makeschapterhead#1{%
  \vspace*{10\p@}%
  {\parindent \z@ \raggedleft \reset@font
            \scshape \vphantom{\@chapapp{} \thechapter}
        \par\nobreak
        \interlinepenalty\@M
    \Huge \bfseries #1\par\nobreak
    %\vspace*{1\p@}%
    \hrulefill
    \par\nobreak
    \vskip 50\p@
  }}

%END Chapter Definition

%BEGIN Title Definition

\makeatletter
\def\thickhrulefill{\leavevmode \leaders \hrule height 1pt\hfill \kern \z@}
\renewcommand{\maketitle}{\begin{titlepage}%
    \let\footnotesize\small
    \let\footnoterule\relax
    \parindent \z@
    \reset@font
    \null\vfil
    \begin{flushleft}
      \huge \@title
    \end{flushleft}
    \par
    \hrule height 4pt
    \par
    \begin{flushright}
      \LARGE \@author \par
    \end{flushright}
    \vskip 60\p@
    \vfil\null
  \end{titlepage}%
  \setcounter{footnote}{0}%
}

%END Title Definition

%Verschissener rotierter Text für verschissene Tabelle 14.1/2
\makeatletter
\newsavebox\zzz
\def\mystrut{%
\dimen@\wd\zzz
\divide\dimen@\thr@@
\advance\dimen@-\dp\@arstrutbox
\rule\z@\dimen@}

\def\rotatezzz{%
\rotatebox{90}{\rlap{\kern-\dp\@arstrutbox\usebox\zzz}}}
%END Verschissener rotierter Text

\makeatother
\title{Software Quality Assurance for Project ``BookExpress''}
\author{Marc A. Harnos\\ {mharnos@gmail.com} \and Joscha Rapp\\ {jraxxo@gmail.com} \and Christian Schulz\\ {crs.s@gmx.net}}
\author{Marc A. Harnos\\ Joscha Rapp\\ Christian Schulz}
\date{October 2012}

\definecolor{tableHead}{HTML}{5393B7}
\definecolor{tableEven}{HTML}{DAF1FF}
\definecolor{tableOdd}{HTML}{ADD0E5}
\definecolor{tableFoot}{HTML}{5393B7}

\definecolor{linkcolour}{rgb}{0,0.2,0.6}

\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour}
\renewcommand{\arraystretch}{1.25}

\begin{document}
\maketitle
\tableofcontents

\chapter*{Document History}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|l|}
\hline 
Editor(s) & Date & Purpose of Editing & Version \\ 
\hline 
Harnos, Rapp, Schulz & 2012-10-01 & Initial Document Creation & v0.01 \\ 
\hline
Harnos, Rapp & 2012-10-08 & Fick Das & v0.02 \\ 
\hline
Schulz & 2012-10-08 & Fick Das Nicht - Überstimmt & v0.03 \\ 
\hline
\end{tabular} 
\caption{Document History Table}
\label{tab:document-history}
\end{table}


\chapter{Introduction}
The software quality assurance concerns itself - as the title already suggests - with the issue of guaranteeing a certain level of quality of the final product. However, the testing does not only occur when the product is finished, as continuous testing is critical to keep the code free from errors early on - the earlier an error gets noticed, the less damage will be done by it. If you're making the mistake of testing at the end of the development phase, chances are pretty high that you may have some fundamental errors in your code, which possibly take a rather long time to fix, as so much more code is directly or indirectly relying on it. If you discover such an error, say, a few hours after it has been coded into the product, you'll be able to fix it rather quickly and everybody else working on the project can adapt themselves to it and change their code accordingly, which may take maybe half an hour or so - if you're discovering the mistake 2 weeks later, the possibility is very high that many others have already written a lot of code that depends on your underlying fundamentals, so a lot of code will have to get either fixed or maybe even rewritten completely, which costs a lot of working hours - and money. This is why continuous quality assurance is so very important - it may seem trivial and tedious at first, but it's nothing compared to the scenario that was just described.

\chapter{Software Testing}
There are multiple ways to test a program or system to ensure that it is free of errors and functions properly. All of those fall in either one of the two big categories:
\begin{itemize}
\item \textbf{Static Testing} or
\item \textbf{Dynamic Testing}.
\end{itemize}

\section{Static Testing}
The big difference between these two is that static methods, such as reviews, walkthroughs or inspections do not require the tester to actually run the program at all. Instead, they use certain tools to analyse the program in a static manner, i.e. scanning the source code for certain abnormalities that could possibly produce errors. One of the big advantages of static software testing methods is that very complex systems that require very powerful hardware to run properly can be analysed and tested without having the aforementioned assets. However, there are always certain types of errors that are very hard to spot when you're not really running the system using test datasets.   
\section{Static Analysis}
Static Analysis is a very powerful static method for software analysis, and also the most common one. It was developed in the mid-70s by Michael Fagan at IBM. The main idea is that a round of qualified inspectors are getting together to discuss a piece of work that shall be integrated into the system in production. The meeting is moderated by a moderator who gets elected beforehand; usually that is the most experienced inspector. The inspection consists of 6 stages:
\begin{itemize}
\item \textbf{Planning:} The inspection is planned by the moderator.
\item \textbf{Overview meeting:} The author describes the background of the work product.
\item \textbf{Preparation:} Each inspector examines the work product to identify possible defects.
\item \textbf{Inspection meeting:} During this meeting the reader reads through the work product, part by part and the inspectors point out the defects for every part.
\item \textbf{Rework:} The author makes changes to the work product according to the action plans from the inspection meeting.
\item \textbf{Follow-up:} The changes by the author are checked to make sure everything is correct.
\end{itemize}
It is important to note that the stages Preparation, Inspection meeting and Rework may be iterated as long as the predefined exit criteria (posed by the moderator) is not met. 
The moderator was already mentioned a few times, however, every person taking part in the code inspection has a certain role to fulfil:
\begin{itemize}
\item \textbf{Author:} The creator of the inspected work product.
\item \textbf{Moderator:} He is leading and coordinating the inspection.
\item \textbf{Reader:} The person reading through the document being inspected; the other inspectors point out defects and errors during the reading.
\item \textbf{Recorder/Scribe:} He documents the defects and mistakes that are found during the inspection.
\item \textbf{Inspector:} Every person who examines the document and points out mistakes and defects.
\end{itemize}

\section{Dynamic Testing}
Dynamic testing is described by executing actual programmed code for given test cases, as in contrast to static testing which involves reviews, inspections and walkthroughs.

Dynamic testing can be performed even if the program itself is not finished yet to test parts of the software, especially individual modules and interfaces. Dynamic testing can be performed automatically on code compilation in form of, for example, unit tests.

There are several types of testing, approaches - one of them is the "box approach", which is separated into "white box"/"glass box" and "black box" testing; there is also a mixture of those approaches, the "grey box" testing.

\subsection{White Box / Glass Box Testing}
White box testing tests internal program functionality and structures, rather than the user functionality. For white box testing, the internal system perspective as well as the programming skills are used to design the test cases - the tester has to know the inner workings of the program to develop those test cases.

Common tests with white box testing include, API testing, fault injection and mutation testing.

A disadvantage of white box testing is, that it does not detect missing functionality of the program, but only implemented errors - so missing design specifications might not be detected.

\subsection{Black Box Testing}
As opposed to the white/glass box testing, in the black box testing the tester does not know anything about the inner workings of the software, the software is seen as a "black box". The tester knows what the software has to do, but not how it accomplishes the results.

Common tests performed with black box testing include, state transition tables, decision table testing, use case testing and specification-based testing.

\paragraph{Specification-based testing}
Specification-based testing takes the requirements of the software design and tests the software functionality for those requirements. The testing consists of previously developed test cases which should perform a certain output for a given input, an expected behaviour is tested. This test can be built with the requirements specifications.

\subsection{Testing levels}
\subsubsection{Unit Testing}
Unit testing, or module testing, test the proper functionality of parts of code, like modules, functions and interfaces. This type of testing is usually written before, or at the same time as the code is developed, by the developers themselves to test if everything is working as expected; as described in the design.

This kind of test will never turn out positive if the function or interface is not implemented by design specifications. Unit testing is a kind of white box testing.

\subsubsection{Integration Testing}
Integration testing tests if interfaces work together according to software design. Such tests can detect interfaces not working properly in the whole scheme of the application, so finding them and fixing the issue is made possible/faster.

Integration tests are used to test if modules/components integrate into interfaces and make sure that the system works as one unit in the end.

\subsubsection{System Testing}
System testing tests the whole system (as one unit) for compliance with the design specifications. As opposed to unit and integration testing, system testing is a kind of black box testing, so no inner workings of the system have to be known to the tester - the tester does only have to test the system as a whole against the specifications.

System testing is in general only performed after the integration testing passes successfully.

\subsubsection{Acceptance Testing}
Acceptance testing is, much like system testing, a black box testing method for testing the whole software against agreed system design/the specification.

The main difference between system testing is, that, as opposed to system testing, the acceptance testing is performed by the client/user - also called user acceptance testing (UAT) or end-user testing.

With a successful acceptance test, the software is delivered to the client as a finished product and testing usually ends here.


\chapter{Quality model - FURPS}

\section{Functionality}

\subsection{Feature Sets}

\subsection{Capabilities}

\subsection{Generality}

\subsection{Security}

\section{Usability}

\subsection{Human Factors}
Entry requirements are basic abilities such as language proficiency, culture and and intelligence level. Of course the learning time of the whole system is reduced to a minimum where no special training courses are required but a maximum of two hours intensive studying to understand the interaction of components and the modules altogether to achieve a measurable level of performance with the system.

The system is design to ensure a high likeability and manageability.

\subsection{Aesthetics}
The design pattern of the whole BookExpress System is based on the idea of simplicity, intuition, highest functionality and modern styling.

Every new user to the system should be able to access the required processes easily with making as few steps as possible and without searching more than a few seconds - the common way to realise such a straightforwarded interface is to use less text but more generalized and standardised symbols which conduce to a clearly not overloaded display. The context menus themselves are more text-based but without lack of simplicity in their meaning to the operator.

\subsection{Consistency}
Identifiers and labels are named consistent throughout the whole system. In general, actions are defined and arranged at one single place to prevent disorder and ambiguity from a users point of view. Menus are compressed in their logical context and are unique in occurrence.

\subsection{Documentation}
The documentation of the system has to be very clear so that in case of possible misunderstandings one can look up every defined process in detail and is able to apprehend the realisation in a comprehensible way.

The description of modules has to be put into effect in a complete and accurate way.


\section{Reliability}

\subsection{Frequency and severity of failure}
Of course errors shouldn't occur at all. Anyhow, if failures appear to happen, they are categorised in different severities. The following table describes the different types of severities.

\begin{table}[H]
\begin{tabular}{p{4cm}p{8cm}}
\textbf{Severity 1} & Error which results in having no active connection the the web interface at all. The Client or Publisher is strongly recommended to first check whether this is a failure of BookExpress or a local error such as unestablished internet connection. call the support team.  \\
\textbf{Severity 2} & Error which results in not correctly working modules of the web interface. A FAQ is set up and describes best practices for troubleshooting. In urgent need the user can call the Support hotline.\\
\textbf{Severity 3} & This severity describes other possible failure functions. The BookExpress Documentation is the best contact point in the first place. The BookExpress website also has a FAQ with detailed information.\\
\end{tabular}
\caption{Severities of failure}
\end{table}

\subsection{Recoverability}
The set up backup server, which is, as well as the web server, running 24/7, ensures a high level of recoverability at possible loss of data. Several security purposes are taken for granted - e.g. a UPS (uninterrupted power supply) is installed for every server in case a unpredictable current interruption has taken place.

\subsection{Predictability}
To avoid predictable errors during a system update, every action of a user is delayed to process after the update has successfully finished. and is up and running. During and update or upgrade the web interface is displaying a notification pop-up which states the current process.

\subsection{Accuracy}

\subsection{Mean time between failure (MTBF)}

\section{Performance}

\subsection{Speed}
The speed of actions and requests (e.g. searching for books) is fast on a high level. This correlates with the response time of general statements and actions.

\subsection{Efficiency}
By using modern techniques of web development and having a very good server system and optimised database transfers as well as an adjusted application server, BookExpress in summary is a highly efficient application.

\subsection{Resource consumption}

\subsection{Throughput}
The different functions and therefore the different databases, have diverse throughputs from low (e.g. Publisher Data) to very high (e.g Order Data). The database server is configured to handle those varying workload easily.

\subsection{Response time}
The response time is very fast. This appears to happen via request data optimisation by using compressed HTML and JSON.


\section{Supportability}

\subsection{Testability}

\subsection{Extensibility}

\subsection{Adaptability}

\subsection{Maintainability}

\subsection{Compatibility}

\subsection{Configurability}

\subsection{Serviceability}

\subsection{Installability}

\subsection{Localisability}


\chapter{Appendices}
\printglossaries\addcontentsline{toc}{section}{Glossary}\addcontentsline{toc}{section}{Acronyms}

\listoffigures\addcontentsline{toc}{section}{List of figures}
\listoftables\addcontentsline{toc}{section}{List of tables}

\end{document}